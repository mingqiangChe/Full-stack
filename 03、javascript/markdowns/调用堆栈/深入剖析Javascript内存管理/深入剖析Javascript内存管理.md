# 内存管理简介

   像C语言这样的底层语言一般都有底层的内存管理接口，比如 `malloc()`和`free()`。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 

## [内存生命周期](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management#内存生命周期)

不管什么程序语言，内存生命周期基本是一致的：  

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放/归还

所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。

### [JavaScript 的内存分配](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management#javascript_的内存分配)

   JS内存空间分为**栈(stack)**、**堆(heap)**、**池(一般也会归类为栈中)**。 其中**栈**存放变量，**堆**存放复杂对象，**池**存放常量，所以也叫常量池。 

##### 基本数据类型存在堆的情况

> 闭包：将内部函数传递到所在的词法作用域以外，都会持有对原始定义作用域的引用。

当一个基本类型被闭包引用之后，就可以长期存在于内存中，这个时候即使他是基本类型，也是会被存放在堆中的。

#### 值的初始化

为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。

```
var n = 123; // 给数值变量分配内存
var s = "azerty"; // 给字符串分配内存

var o = {
  a: 1,
  b: null
}; // 给对象及其包含的值分配内存

// 给数组及其包含的值分配内存（就像对象一样）
var a = [1, null, "abra"];

function f(a){
  return a + 2;
} // 给函数（可调用的对象）分配内存

// 函数表达式也能分配一个对象
someElement.addEventListener('click', function(){
  someElement.style.backgroundColor = 'blue';
}, false);
```

#### 通过函数调用分配内存

有些函数调用结果是分配对象内存：

```
var d = new Date(); // 分配一个 Date 对象

var e = document.createElement('div'); // 分配一个 DOM 元素
```

有些方法分配新变量或者新对象：

```
var s = "azerty";
var s2 = s.substr(0, 3); // s2 是一个新的字符串
// 因为字符串是不变量，
// JavaScript 可能决定不分配内存，
// 只是存储了 [0-3] 的范围。

var a = ["ouais ouais", "nan nan"];
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2);
// 新数组有四个元素，是 a 连接 a2 的结果
```

### [使用值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management#使用值)

使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。

## [垃圾回收算法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management#垃圾回收)

如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。

### [引用](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management#引用)

垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它[原型](https://developer.mozilla.org/en-US/JavaScript/Guide/Inheritance_and_the_prototype_chain)的引用（隐式引用）和对它属性的引用（显式引用）。

在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

### [引用计数垃圾收集](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management#引用计数垃圾收集)

这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

#### 示例

```
var o = {
  a: {
    b:2
  }
};
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集


var o2 = o; // o2变量是第二个对“这个对象”的引用

o = 1;      // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有

var oa = o2.a; // 引用“这个对象”的a属性
               // 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
           // 但是它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了
```

#### 限制：循环引用

该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

```
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
```

#### 实际例子

IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏：

```
var div;
window.onload = function(){
  div = document.getElementById("myDivElement");
  div.circularReference = div;
  div.lotsOfData = new Array(10000).join("*");
};
```

在上面的例子里，`myDivElement` 这个 DOM 元素里的 `circularReference 属性`引用了 `myDivElement`，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 `lotsOfData` 属性)，而这个数据占用的内存将永远不会被释放。

### [标记-清除算法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management#标记-清除算法)

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。

从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

#### 循环引用不再是问题了

在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。

#### 限制: 那些无法从根对象查询到的对象都将被清除

尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。 



## V8内存管理

### 弊病

1. 为浏览器设计，不太可能遇到大量内存的场景，64位下 新生代默认的最大内存空间为32MB，老生代默认的最大内存空间为1400MB。
2. 垃圾回收会导致线程短暂停止线程从而引起性能问题。

### 回收策略：分代式垃圾回收机制

- 新生代：大多数对象被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立
- 老生代：这里包含大多数可能存在指向其他对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里

### 回收算法

#### 新生代

新生代中的对象主要通过Scavenge算法进行垃圾回收。

![1583434994243.png](%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Javascript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/669912916-5e61527d2644b_fix732.png)

内存分配空间时，分为两个区域：From空间和To空间。

- 当分配新的对象时，总是往From空间中分配。
- 在回收时，先扫描From空间，将From空间中存活的对象复制到To空间中，然后将From空间的内存全部释放，最后将From和To的角色交换

特点：

- 只能使用一半的内存，但由于只需要复制存活对象，因此该算法非常适合应用在新生代垃圾回收中，因为新生代中对象的生命周期较短，垃圾回收时多为未存活对象。
- 不会在内存中留下碎片

#### 对象晋升

在执行Scavenge的存活对象复制操作时进行对象是否晋升的判断（新生代迁移至老生代）

晋升标准：

1. 该对象已经进行过一次Scavenge回收；
2. To空间已使用了25%。

![1583435096879.png](%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Javascript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/1676402924-5e615285b4b51_fix732.png)

#### 老生代

> 对于老生代中的对象，由于存活对象占较大比重，再采用Scavenge的方式会有两个问题：
>
> - 一是存活对象较多，复制存活对象的效率将会很低；
> - 另一个问题则是由于老生代空间较大，空闲一半空间的做法对内存是极大的浪费

主要采用了Mark-Sweep和Mark-Compact两种算法相结合的方式进行垃圾回收。

##### Mark-Sweep

分为标记阶段和清除阶段：

- 标记阶段会遍历老生代空间的所有对象，将其中非存活的对象标记出来；
- 清除阶段则会将标记的死亡对象一一清除，释放内存空间。

![1583435310890.png](%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Javascript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/2412061425-5e61529ecaeb0_fix732.png)

缺点：回收后会在内存中留下一些碎片，如果这时候需要分配大对象，不连续的内存可能无法满足需求

##### Mark-Compact

分为标记和合并阶段：

- 标记阶段会遍历老生代空间的所有对象，将其中非存活的对象标记出来；
- 合并阶段会将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存

![1583435431583.png](%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Javascript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/1796540968-5e6152aa36286_fix732.png)

### 算法对比

| 回收算法     |                          Mark-Sweep                          | Mark-Compact                       | Scavenge                       |
| ------------ | :----------------------------------------------------------: | ---------------------------------- | ------------------------------ |
| 速度         |                             中等                             | 最慢                               | 最快                           |
| 空间开销     |                         少（有碎片）                         | 少（无碎片）                       | 双倍空间（无碎片）             |
| 是否移动对象 |                              否                              | 是                                 | 是                             |
| 主动启动时机 |                          进程空闲时                          | 进程空闲时                         | 进程空闲时（频率低）           |
| 被动启动时机 | 1.老生代空间中被分配了一定数量的对象的时候；2.老生代空间里没有新生代空间大小相同的空间的时候 | 老生代空间的碎片到达一定数量的时候 | From空间没有足够的空间分配对象 |



参考链接：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management

https://muyiy.cn/blog/1/1.4.html#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6

https://segmentfault.com/a/1190000021927852