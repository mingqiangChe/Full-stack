# 面试题

## css

### 布局

### 定位

### 移动端响应式



### 元素居中

flex 方法

```scss
body {
  width: 100%;
  /* 父元素要有具体高 */
  height: 400px;
  display: flex;
  justify-content: center;
  align-items: center;
}
.xx {
  width: 200px;
  height: 200px;
  background-color: red;
}
```









## ES语法

### 事件循环机制

eventloop，单线机制。这里涉及执行栈和任务队列。每次执行都称为一次 tick。执行栈执行完毕后，从任务栈取出任务执行。顺序并不是按照所谓二叉树中的先进后出或先进先出这样子，而是秉持着同步先行，同步任务执行完毕后执行异步任务。这时异步任务又被分为宏任务和微任务，宏任务有定时器 发布订阅模式以及 async await，微任务则是 promise。如果存在多个宏任务则执行先进先出原则，当所有宏任务中的微任务执行完毕后再执行宏任务。如此反复

### 闭包

定义在一个函数内部的函数

内部函数调用外部函数内变量使用，并通过 return 的方式让外部函数调用获得内部函数处理变量。

就还有一个功能就是私有变量方法存储。每次调用函数都会使用上次闭包 return 出来的变量值。

### 作用域

### 异步

### 单线程



### 原型 原型链



## webAPI

### DOM

### BOM

### Ajax 跨域

### 事件存储



## 开发环境

### 版本管理

### 调试抓包

### 打包构建



## 运行环境

### 页面渲染

### 性能优化

### web安全



## 网络通讯

### headers

### Restful API

### 缓存策略





## vue

### 双向数据绑定原理

### 作用域插槽

**在封装组件的过程中，可以为预留的 <slot> 插槽绑定 props 数据，这种带有 props 数据的 <slot> 叫做“作用域插槽”。**



### vue 获取不到修改的值

涉及到 vue 异步更新。vue 有两种解决办法，一种是等待数据所有变化完，到最后一个时。另一种是等待数据变化后直接跳到下一次等待 dom 重新渲染后调用 this.$nextStick 方法获取

### 父子组件渲染过程

加载渲染过程

父组件 before created-父组件 create-父组件 before mounted-子组件 before created-子组件 create-子组件 before mounted-子组件 mounted-父组件 mounted

子组件更新过程

父组件 beforeUpdate-子组件 beforeUpdate-子组件 updated-父组件 updated









实现马赛克

svg画圆

js 输出 a b  c    b是顺序执行 执行完b再执行a

for的key可不可以不用或者用数组替换

webpack plugin意义

map方法 映射 需要return
